<!DOCTYPE html>
<html lang='en'>

<head>
  <meta charset='utf-8'>
<meta name='viewport' content='width=device-width, initial-scale=1'>
<meta name='description' content='Computer processing is the act by which the world of the computer is constructed. We can call it a world because it appears to exist unto itself, persisting its environment and taking scripted actions well outside of our awareness. Modern computers rarely shut off completely, so the illusion of persistence (&ldquo;my user desktop is still there even when my computer is asleep; I just drop in on it now and then&rdquo;) is not entirely an illusion.'>

<meta property='og:title' content='Is code a performative speech act? • Minimum Viable Blog'>
<meta property='og:description' content='Computer processing is the act by which the world of the computer is constructed. We can call it a world because it appears to exist unto itself, persisting its environment and taking scripted actions well outside of our awareness. Modern computers rarely shut off completely, so the illusion of persistence (&ldquo;my user desktop is still there even when my computer is asleep; I just drop in on it now and then&rdquo;) is not entirely an illusion.'>
<meta property='og:url' content='http://isaaclyman.com/blog/posts/code-performative-speech/'>
<meta property='og:site_name' content='Minimum Viable Blog'>
<meta property='og:type' content='article'><meta property='article:section' content='Posts'><meta property='article:published_time' content='2022-09-23T08:50:34-06:00'/><meta property='article:modified_time' content='2022-09-23T08:50:34-06:00'/>

<meta name="generator" content="Hugo 0.124.1">

  <title>Is code a performative speech act? • Minimum Viable Blog</title>
  <link rel='canonical' href='http://isaaclyman.com/blog/posts/code-performative-speech/'>
  
  <link rel='icon' href='/blog/favicon.png'>
<link rel='stylesheet' href='https://fonts.googleapis.com/css?family=Ubuntu:400,400i,700&subset=latin'>
<link rel='stylesheet' href='/blog/css/main.d02777fd.css'>

  <link rel='stylesheet' href='/blog/css/custom.css'>

  <link rel='stylesheet' href='/blog/css/print.css'>


<script async src="https://www.googletagmanager.com/gtag/js?id=G-QX2T3WXRC9"></script>
<script>
var doNotTrack = false;
if (!doNotTrack) {
	window.dataLayer = window.dataLayer || [];
	function gtag(){dataLayer.push(arguments);}
	gtag('js', new Date());
	gtag('config', 'G-QX2T3WXRC9', { 'anonymize_ip': false });
}
</script>


</head>


<body class='page'>
  <div class='site'>
    <header id='header' class='header-container'>
      <div class='site-header'>
        <nav id='navmenu' aria-label='Main Menu'>
  <ul class='main-menu'>
    
    <li>
      <a href='/blog/posts/' 
        
      >{ Archive }</a>
    </li>
    
    <li>
      <a href='/blog/posts/introduction' 
        
      >{ Contact }</a>
    </li>
    
    <li>
      <a href='/blog/index.xml' 
        
      >{ RSS }</a>
    </li>
    
  </ul>
</nav>

        <div class='site-info'>
          
          <p class='site-title title'>Minimum Viable Blog</p>
          
          <p class='site-description'>Software construction, opinion, and self</p>
        </div>
      </div>
    </header>


<main class='main'>
  <article lang='en' class='entry'>
    <header class='entry-header'>
  <div class='entry-info'>
    <p class="entry-genre">
      Technology
    </p>
    <h1 class='entry-title title'>Is code a performative speech act?</h1>
    
  </div>
  
<div class='meta'>
  <span class='posted-on'>
    <svg class='icon' viewbox='0 0 24 24' stroke-linecap='round' stroke-linejoin='round' stroke-width='2' aria-hidden='true'>
  
  <rect x="3" y="4" width="18" height="18" rx="2" ry="2"/>
  <line x1="16" y1="2" x2="16" y2="6"/>
  <line x1="8" y1="2" x2="8" y2="6"/>
  <line x1="3" y1="10" x2="21" y2="10"/>
  
</svg>

    <span class='screen-reader'>Posted on </span>
    <time class='date' datetime='2022-09-23T08:50:34-06:00'>Sep 23, 2022</time>
  </span>
  
  
  <span class='reading-time'>
    <svg class='icon' viewbox='0 0 24 24' stroke-linecap='round' stroke-linejoin='round' stroke-width='2' aria-hidden='true'>
  
  <circle cx="12" cy="12" r="10"/>
  <polyline points="12 6 12 12 15 15"/> 
  
</svg>

    11 mins read
  </span>
  
</div>


</header>

    <div class='entry-content'>
  <p>Computer processing is the act by which the world of the computer is constructed. We can call it a world because it appears to exist unto itself, persisting its environment and taking scripted actions well outside of our awareness. Modern computers rarely shut off completely, so the illusion of persistence (&ldquo;my user desktop is still there even when my computer is asleep; I just drop in on it now and then&rdquo;) is not entirely an illusion. And in the overlapping world of the Internet, availability is a given: it is prioritized by server providers and taken for granted by users. We expect that Google is still there when we&rsquo;re not looking at it&mdash;we behave as if it&rsquo;s there even when <em>nobody</em> is looking at it.</p>
<p><sup>It may not be technically accurate to assume that a website exists when it&rsquo;s not being viewed. Our experience of a website is not what is stored on physical media (code and data) but rather an opinionated interpretation of it by another application. If we were to routinely experience the part of the website that literally persists between viewings we&rsquo;d get considerably less value out of the web.</sup></p>
<p>We can also define the computer as a world because it is separate from our own in well-defined ways. A command spoken or action taken that does not target one of the extremely constrained inputs of the computer will have no effect on its world, and an event within the world of the computer has no effect outside of it unless it crosses the threshold of one of its extremely constrained outputs. (Sometimes computers catch fire but that&rsquo;s the result of physical processes outside the computer&rsquo;s world, even if they respond to processes inside it.)</p>
<p>All of a computer&rsquo;s behaviors are described by hardware (the material facts of electronic chips and cables) and software (the instructions stored as data on the computer and purpose-built to trigger behaviors in its hardware). Coding is the act of creating software. So it&rsquo;s reasonable to ask, <em>is coding a purely performative speech act?</em> Here I&rsquo;m referring to J. L. Austin&rsquo;s theory of the &ldquo;speech act,&rdquo; something that is spoken not to describe reality but to change it. Classic examples include &ldquo;I do&rdquo; in the marriage ceremony or &ldquo;you&rsquo;re fired&rdquo; in the workplace. When we speak those phrases we are not simply communicating information about the way things are; we are making things substantially different&mdash;speaking a change into existence.</p>
<p>Of course, speech acts are not restricted to speaking aloud. &ldquo;Speech&rdquo; here means the same thing as in &ldquo;free speech,&rdquo; so the definition includes anything that is spoken, written, signed, painted, or danced. And it is by the definition of free speech that we can affirm part of our premise. Computer code is free speech; this was affirmed by courts in the United States <a href="https://www.eff.org/deeplinks/2015/04/remembering-case-established-code-speech">in 1996</a> and again <a href="http://digital-law-online.info/lpdi1.0/treatise50.html">in 2001</a>. If it is free speech, it must be speech.</p>
<p>Yet code is different from other forms of speech because, at least in the platonic ideal, its meaning is deterministic. Programmers write code that targets a compiler, an interpreter, or sometimes a chip. And in the context of that target the code has a single, eternal meaning. The programmer is generally not perfectly aware of that meaning&mdash;this is the origin of bugs&mdash;but the meaning is static nonetheless as long as the context does not change. The computer does not filter code through the lens of experience or social dynamics or emotional awareness. It cannot bear ambiguity. The code defines a very specific set of behaviors or else nothing.</p>
<p>So at first brush it seems that code is performative speech: it does things. However, it could also be argued that code is entirely <em>non</em>-performative&mdash;that it&rsquo;s 100% descriptive. After all, the act of writing code does not itself have an effect. If I write code on a piece of paper and shred it, it doesn&rsquo;t really matter what behaviors the code indicates. Likewise if I write code in a computer file but never execute it, there is no effect. It&rsquo;s the act of running code (assuming significant acts by the computer to parse, compile and process it) that actually <em>performs</em>.</p>
<p>Nonetheless, we have to accept that writing code without compiling or running it is still coding. One does not always have the convenience of writing code in the presence of something that can immediately understand it. In less-than-ideal situations, we have to send our code to a remote device or person who will run it. They are not coding; we are coding. They are simple executing what we have already coded. How can our code be a performance if we are detached from the gatekeeper of its effects?</p>
<p>This argument makes sense until we apply the same argument to non-code speech. Language doesn&rsquo;t take effect unless it&rsquo;s received, interpreted, and acted upon. &ldquo;I do&rdquo; isn&rsquo;t a valid oath of marriage if spoken in a language nobody understands. &ldquo;You&rsquo;re fired&rdquo; doesn&rsquo;t terminate someone&rsquo;s employment if shouted in an empty room or by someone who doesn&rsquo;t have corporate power. In either case the statement might be written on a piece of paper and presented later without losing validity. Speech is performative in the moment it&rsquo;s accepted. Linguists have disagreed as to whether the social or linguistic context is more important, and to be fair, one can make oaths to oneself or quit a job without the acquiescence of one&rsquo;s boss. But the audience still exists&mdash;to be one&rsquo;s own audience is not to speak without an audience.</p>
<p>Code appears not to fit the concept of self-directed performance. Perhaps simple code could be written and then followed, line by line, by a human acting the part of a compiler. But this is subversion. The code would become a recipe, not an application. The human would inevitably attach meaning and actions to the code that aren&rsquo;t part of its literal meaning. This is what makes code unique among speech acts: the fact that it has a literal meaning at all, one that can be unambiguous in a particular context. Not even the strictest legal contract can transcend human interpretation. Code does this almost always. In this way it&rsquo;s more like math than writing.</p>
<p>It should be conceded that computer hardware is designed and (indirectly) built by humans, who even with strict mathematical parameters are constrained to produce ambiguity. It may not be true at the level of infinite detail that all code is completely unambiguous before it runs. For example, it&rsquo;s often necessary to run a piece of code hundreds or thousands of times to benchmark its performance; any one execution may be several milliseconds slower or faster than the median. Where code stands out, though, is that its interpretive context can be <em>understood</em> to be unambiguous, even proved using formal logic, whereas with natural language in a social environment this is impossible.</p>
<p>Code, then, is a speech act. It is a performance upon the world of the computer. But is it <em>purely</em> performative? There is a second context within which we can argue it is not.</p>
<p>In <em>Structure and Interpretation of Computer Programs</em> appears the oft-quoted line, &ldquo;Programs must be written for people to read, and only incidentally for machines to execute.&rdquo; This mantra makes sense if taken non-literally, as an exercise for the programmer&rsquo;s mind rather than an explicit goal. Code rarely, maybe never, fulfils its purpose unless it executes successfuly. But the character of a piece of code can&rsquo;t be fully described in machine terms. It has never been the collective fortune of software programs to be written once, compiled, and never seen again. Rather, they are written, tested, tweaked, shared, collaborated upon, and continually re-interpreted by human beings until the end of their useful life (or almost). In this way, a computer program is less like a spell cast upon another world than a description of some mundane process that&rsquo;s important for another programmer to understand in painstaking detail.</p>
<p>Said another way, to describe a program only in terms of its <em>effects</em> ignores the unlimited means and variations by which those effects can be had, and each variation carries a meaning that is apparent not to a machine but to another person. By naming various identifiers in oblique ways, we could reproduce the collected works of Shakespeare in a program that merely adds numbers together. To do so would be absurd. Yet it&rsquo;s hard to deny that a message would be taken from such a program beyond and aside from the literal facts of its operation.</p>
<p>So it is not only the compiler that listens to us when we speak in code. It is ourselves and our fellow programmers. On GitHub, it may be an audience of millions.</p>
<p>Even when a program is written by a lone programmer, compiled in a way that removes any ambiguities or stylistic choices, and distributed directly to end users, its value is rarely exhausted by simply executing it. Software is interactive. The story of the program is not in the bytecode itself but in the way you use it. I mean this literally and concretely. The program may be following algorithms, moving data around in memory, and calculating values, but this is not something the user experiences directly. The effect of those actions on the real world is intangible above the quantum level and ineffectual by any standard. They must be interpreted first by a computing context, second by a peripheral device (such as a monitor), and third by the user. When they are communicated to the user and understood, that is the moment where the software has had an effect. Typically this becomes a game of back-and-forth between user and machine, the software accomplishing highly predictable tasks at the user&rsquo;s direction and the user accomplishing more abstract tasks under the principle of a preexisting process, which may in turn be framed or enforced by the software.</p>
<p>To use software is to receive an idea. An accounting program is an automaton that describes an accounting process. A video game expresses a way of interacting with a problem or environment. A media player teaches us a way to watch videos: here is a frame to look within, here is a button that will pause the video while you take a leak.</p>
<p>So, then, a computer program is less a speech act and more a communication. I write code not to act upon you unilaterally, in a position of sovereign authority, but to communicate with you and allow you to respond to me by proxy. Even the software that autonomously instructs rollers and mechanical arms on an assembly line is fundamentally a transfer of information. It performs calculations in a digital environment and produces signals; with luck, they receive those signals and perform actions in the real world. As with any software, there is a boundary between worlds that must be crossed.</p>
<p>It may even be argued that a computer program can&rsquo;t be conceived as a speech act without robbing the phrase of all meaning. When we arrange and manipulate computer memory in order to carry a message, is that so different from the way we arrange and manipulate the molecules around us when we produce sound by speaking? All speech would be performative if we counted the creation of compression waves in a medium or the reflection of photons. But we do not. We use the phrase <em>speech act</em> as a way of categorizing some speech as different from other speech. So even if it&rsquo;s true that within the constructed world of the computer, code is purely performative, it&rsquo;s equally true that in the natural world it isn&rsquo;t.</p>
<p>The obvious question here is, &ldquo;what if I write a computer program to inform an employee that they&rsquo;re fired?&rdquo; Of course code, like any other form of expression, can be the medium for a speech act. (It cannot ever be the agent of it.) This program is a performative speech act, but it is not <em>purely</em> performative. No speech act between two people ever is.</p>
<p>As a tangent&mdash;this cuts at a question that&rsquo;s frequently discussed in the context of self-driving cars. If a computer drives a car into a person and injures them, who is at fault? This is a performance on the natural world; the fact that it&rsquo;s mediated by code makes very little difference. One answer is &ldquo;whoever had the intrinsic authority to navigate the car in the first place.&rdquo; This places blame on the owner, assuming the car can also be driven by hand. But a more insightful answer is that since the owner gave up their authority to the autopilot, the blame rests on whoever told the car (immediately or by proxy) to drive in that direction and at that speed. This implicates not just a single programmer or team, but likely an entire corporation. The car and its code are mere tools. The people that produced it are its operators, however distant. Their authority to act on the world is proven by the effect of their instructions. No other origin exists.</p>
<p>Even in the context of artificial intelligence there exists a natural origin for any act. Artificial intelligence is an algorithm that acts on patterns. The algorithm is selected by a person, the patterns are designated by a person, and the act is authorized by a person. The only amnesty we can offer the programmer is that they are speaking an impossible language&mdash;one that is alien because it is unambiguous&mdash;and therefore should be treated like someone who doesn&rsquo;t fully know what they are saying.</p>

</div>

    
<footer class='entry-footer'>
  
    
      
      

<div class='categories'>
  <span class='category-icon'>
    <svg class='icon' viewbox='0 0 24 24' stroke-linecap='round' stroke-linejoin='round' stroke-width='2' aria-hidden='true'>
  
  <path d="M22,19a2,2,0,0,1-2,2H4a2,2,0,0,1-2-2V5A2,2,0,0,1,4,3H9l2,3h9a2,2,0,0,1,2,2Z"/>
  
</svg>

  </span>
  <span class='screen-reader'>Categories: </span><a class='category' href='/blog/categories/philosophy'>philosophy</a>, <a class='category' href='/blog/categories/development'>development</a></div>

    
  
    
  
</footer>


  </article>

  
    
<nav class='entry-nav'>
  <div class='entry-nav-links'><div class='prev-entry'>
      <a href='http://isaaclyman.com/blog/posts/30-years/'>
        <span aria-hidden='true'><svg class='icon' viewbox='0 0 24 24' stroke-linecap='round' stroke-linejoin='round' stroke-width='2' aria-hidden='true'>
  
  <line x1="20" y1="12" x2="4" y2="12"/>
  <polyline points="10 18 4 12 10 6"/>
  
</svg>
 Previous</span>
        <span class='screen-reader'>Previous post: </span>I&#39;m 30.</a>
    </div><div class='next-entry'>
      <a href='http://isaaclyman.com/blog/posts/logging-in/'>
        <span class='screen-reader'>Next post: </span>Logging in, a thing we all hate<span aria-hidden='true'>Next <svg class='icon' viewbox='0 0 24 24' stroke-linecap='round' stroke-linejoin='round' stroke-width='2' aria-hidden='true'>
  
  <line x1="4" y1="12" x2="20" y2="12"/>
  <polyline points="14 6 20 12 14 18"/>
  
</svg>
</span>
      </a>
    </div></div>
</nav>


  

  
    <div class='comments-container'>
  
</div>

  
</main>

    <footer id='footer' class='footer-container'>
      <div class='footer'>
        <div class='social'>
  <nav aria-label='Social Menu'>
    <ul class='social-menu'></ul>
  </nav>
</div>

        <div class='copyright'>
          <p>© 2017 by Isaac Lyman. Site powered by Hugo and GitHub Pages.</p>

        </div>
      </div>
    </footer>

  </div>

  <script src='/blog/js/main.af838dd5.js'></script>
  
    <script src='/blog/js/custom.js'></script>
  

</body>

</html>

